# Algorithm_test
The implementation of Algorithms according to "Introduction to Algorithm" using C++.

1. heapSort
在程序设计相关领域，堆(Heap)的概念主要涉及到两个方面：

一种数据结构，逻辑上是一颗完全二叉树，存储上是一个数组对象（二叉堆）。
垃圾收集存储区，是软件系统可以编程的内存区域。
本文所说的堆，指的是前者。

堆排序的时间复杂度是O(nlgN)，与快速排序达到相同的时间复杂度。但是在实际应用中，我们往往采用快速排序而不是堆排序。这是因为快速排序的一个好的实现，往往比堆排序具有更好的表现。堆排序的主要用途，是在形成和处理优先级队列方面。另外，如果计算要求是类优先级队列（比如，只要返回最大或者最小元素，只有有限的插入要求等），堆同样是很适合的数据结构。

基础知识
堆一般用数组表示，比如数组A数组的长度Length(A)，堆在数组中的元素个数HeapSize(A)。一般说来，HeapSize(A) <= Length(A)，因为数组A当中可能有一些元素不在堆中。

假设节点I是数组A中下标为i的节点。

Parent(i) : return Floor(i/2); //I的父节点下标，Floor(i)表示比i小的最大整数。
Left(i) : return 2*i; //I的左子节点
Right(i) : return 2*i+1; //I的右子节点
含有n个元素的堆A的高度是: Floor(lgn)。

堆的基本操作
MaxHeapify( A, i ):
保持堆的性质。假设数组A和下标i，假定以Left(i)和Right(i)为根结点的左右两棵子树都已经是最大堆，节点i的值可能小于其子节点。调整节点i的位置。

BuildMaxHeap( A ):
从一个给定的数组建立最大堆。子数组A[ floor(n/2)+1 .... ... n]中的元素都是树的叶节点(完全二叉树的基本性质)。从索引 ceiling(n/2)开始一直到1，对每一个元素都执行MaxHeapify，最终得到一个最大堆。

堆排序 HeapSort( A ):
堆排序算法的基本思想是，将数组A创建为一个最大堆，然后交换堆的根(最大元素)和最后一个叶节点x，将x从堆中去掉形成新的堆A1，然后重复以上动作，直到堆中只有一个节点。

优先级队列算法-增加某元素的值(优先级) : HeapIncreaseKey( A, i, key )
增加某一个元素的优先级后（元素的值），该元素应该向上移动，才能保持堆的性质。

优先级队列算法-插入一个元素: Insert( S, x ) 将x元素插入到优先级队列S中。
主要思路是，将堆的最后一个叶节点之后，扩展一个为无穷小的新叶节点，然后增大它的值为x的值。

本来我只打算随便写个小程序的，但是发现，可以写个更通用的程序， 使用了C++模板编程。

2. 快速排序（Quicksort）

快排是对冒泡排序的一种改进。

它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

算法过程：设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是： 

　　1）设置两个变量I、J，排序开始的时候：I=1，J=N-1；

　　2）以第一个数组元素作为关键数据，赋值给X，即 X=A[0]；

　　3）从J开始向前搜索，即由后开始向前搜索（J=J-1），找到第一个小于X的值，让该值与X交换；

　　4）从I开始向后搜索，即由前开始向后搜索（I=I+1），找到第一个大于X的值，让该值与X交换；

　　5）重复第3、4步，直到 I=J；

　　例如：待排序的数组A的值分别是：（初始关键数据：X=49）

　　A[0] 、 A[1]、 A[2]、 A[3]、 A[4]、 A[5]、 A[6]：

　　49 38 65 97 76 13 27

　　进行第一次交换后： 27 38 65 97 76 13 49

　　( 按照算法的第三步从后面开始找)

　　进行第二次交换后： 27 38 49 97 76 13 65

　　( 按照算法的第四步从前面开始找>X的值，65>49,两者交换，此时：I=3 )

　　进行第三次交换后： 27 38 13 97 76 49 65

　　( 按照算法的第五步将又一次执行算法的第三步从后开始找

　　进行第四次交换后： 27 38 13 49 76 97 65

　　( 按照算法的第四步从前面开始找大于X的值，97>49,两者交换，此时：J=4 )

　　此时再执行第三步的时候就发现I=J，从而结束一躺快速排序，那么经过一趟快速排序之后的结果是：27 38 13 49 76 97 65，即所以大于49的数全部在49的后面，所以小于49的数全部在49的前面。

　　快速排序就是递归调用此过程——在以49为中点分割这个数据序列，分别对前面一部分和后面一部分进行类似的快速排序，从而完成全部数据序列的快速排序，最后把此数据序列变成一个有序的序列，根据这种思想对于上述数组A的快速排序的全过程如图6所示：

　　初始状态 {49 38 65 97 76 13 27}

　　进行一次快速排序之后划分为 {27 38 13} 49 {76 97 65}

　　分别对前后两部分进行快速排序 {27 38 13} 经第三步和第四步交换后变成 {13 27 38} 完成排序。

　　{76 97 65} 经第三步和第四步交换后变成 {65 76 97} 完成排序。

 

递归的算法的退出条件是前面后面的比较基准值都是前面或后面 没有的比较了就可以了

3.归并排序

归并排序 (merge sort) 是一类与插入排序、交换排序、选择排序不同的另一种排序方法。归并的含义是将两个或两个以上的有序表合并成一个新的有序表。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。 
两路归并排序算法思路
①把 n 个记录看成 n 个长度为 l 的有序子表；
②进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表； 
③重复第②步直到所有记录归并成一个长度为 n 的有序表为止。

现分三步来讨论。首先从宏观上分析，首先让子表表长 L=1 进行处理；不断地使 L=2*L ，进行子表处理，直到 L>=n 为止，把这一过程写成一个主体框架函数 mergesort 。然后对于某确定的子表表长 L ，将 n 个记录分成若干组子表，两两归并，这里显然要循环若干次，把这一步写成一个函数 mergepass ，可由 mergesort 调用。最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge ，由 mergepass 来调用
